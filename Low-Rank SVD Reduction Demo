#!/usr/bin/env python3
# -*- coding: utf-8 -*-


from __future__ import annotations

import sys
import numpy as np
from scipy.sparse.linalg import svds
from scipy.linalg import svd
import matplotlib.pyplot as plt

# Using a professional style for 2026 visuals
plt.style.use('seaborn-v0_8-muted') 

def generate_low_rank_matrix(
    m: int,
    n: int,
    rank: int,
    noise_std: float = 0.0,
    rng: np.random.Generator = None,
) -> tuple[np.ndarray, np.ndarray]:
    """Generate a true low-rank signal with orthonormal bases."""
    if rng is None:
        rng = np.random.default_rng()

    # Orthonormal bases via QR decomposition
    U, _ = np.linalg.qr(rng.standard_normal((m, rank)))
    V, _ = np.linalg.qr(rng.standard_normal((n, rank)))
    
    # Singular values: strong signal to ensure it stands above noise
    s = np.logspace(2, 0.5, rank) 
    L_clean = (U * s) @ V.T

    A = L_clean.copy()
    if noise_std > 0:
        A += noise_std * rng.standard_normal((m, n))

    return A, L_clean

def get_optimal_threshold(m: int, n: int, sigma: float) -> float:
    """Gavish-Donoho Optimal Hard Threshold for unknown noise variance."""
    beta = min(m, n) / max(m, n)
    omega = 0.56 * beta**3 - 0.95 * beta**2 + 1.82 * beta + 1.43
    return omega * sigma * np.sqrt(max(m, n))

def plot_results(s: np.ndarray, threshold: float, true_rank: int, est_rank: int):
    """Visualizes the singular value decay with high-fidelity formatting."""
    fig, ax = plt.subplots(figsize=(11, 6), constrained_layout=True)
    
    # Plot all singular values
    ax.semilogy(s, 'o', ms=3, color='#2c3e50', alpha=0.4, label='Singular Values (Spectrum)')
    
    # Highlight the values above the threshold
    ax.semilogy(s[:est_rank], 'o', ms=5, color='#e74c3c', label='Recovered Signal')
    
    # Threshold and Rank lines
    ax.axhline(threshold, color='#2980b9', ls='--', lw=2, label=f'Optimal Threshold (τ)')
    ax.axvline(true_rank, color='#27ae60', ls=':', lw=2, label=f'True Rank ({true_rank})')
    
    ax.set_title("SVD Spectrum Analysis & Automated Denoising", fontsize=14, pad=15)
    ax.set_xlabel("Singular Value Index", fontsize=12)
    ax.set_ylabel("Magnitude (Log Scale)", fontsize=12)
    
    # Enhanced legend
    ax.legend(loc='upper right', frameon=True, facecolor='white', framealpha=0.9)
    ax.grid(True, which="both", ls='-', alpha=0.1)
    
    plt.show()

def main():
    # Parameters
    M, N, RANK = 1000, 500, 40
    SIGMA = 0.5  # Noise level
    SEED = 2026
    rng = np.random.default_rng(SEED)

    # 1. Generate Data
    A, L_clean = generate_low_rank_matrix(M, N, RANK, SIGMA, rng)
    
    # 2. Compute Spectrum
    # We use full SVD here to see the "tail" of the noise
    U, s, Vh = svd(A, full_matrices=False)
    
    # 3. Apply Gavish-Donoho Denoising
    tau = get_optimal_threshold(M, N, SIGMA)
    rank_est = np.sum(s > tau)
    
    # 4. Reconstruct
    s_thresh = s.copy()
    s_thresh[s <= tau] = 0  # Hard thresholding
    A_denoised = (U[:, :rank_est] * s[:rank_est]) @ Vh[:rank_est, :]
    
    # 5. Metrics
    error = np.linalg.norm(L_clean - A_denoised, ord='fro')
    
    print(f"\n--- SVD Denoising Report ---")
    print(f"Matrix Size      : {M} x {N}")
    print(f"True Signal Rank : {RANK}")
    print(f"Estimated Rank   : {rank_est}")
    print(f"Threshold (τ)    : {tau:.4f}")
    print(f"Frobenius Error  : {error:.4f}")
    print(f"----------------------------\n")
    
    plot_results(s, tau, RANK, rank_est)

if __name__ == "__main__":
    main()
